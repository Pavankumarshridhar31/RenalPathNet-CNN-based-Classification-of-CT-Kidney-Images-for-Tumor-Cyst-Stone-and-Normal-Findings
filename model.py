# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colaboratory.


"""

! unzip ct-kidney-dataset-normal-cyst-tumor-and-stone.zip

!pip install split-folders

from keras.preprocessing.image import ImageDataGenerator
import numpy as np
import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import os
import keras
import cv2
import seaborn as sns
from tensorflow.keras.utils import load_img
from keras.models import Sequential
from keras.layers import Conv2D, Flatten, MaxPool2D, Dense
import matplotlib.pyplot as plt
from keras.preprocessing.image import ImageDataGenerator
import numpy as np
from skimage import transform

from sklearn.metrics import confusion_matrix
from sklearn.metrics import precision_recall_fscore_support
import seaborn as sns
import splitfolders

kidney_data_df= pd.read_csv("/content/kidneyData.csv", header=0)

kidney_data_df.head()

kidney_data_df.tail()

kidney_data_df.dtypes

kidney_data_df.info()

kidney_data_df['Class'].unique()

kidney_classes = kidney_data_df['Class'].value_counts()

sum_of_element = kidney_classes.sum()

# Display unique values in the 'Class' column
unique_classes = kidney_data_df['Class'].unique()

# Count occurrences of each class
kidney_classes = kidney_data_df['Class'].value_counts()

# Calculate the total number of elements
sum_of_elements = kidney_classes.sum()

# Print unique classes
print("Unique kidney classes:\n", unique_classes)

# Print class counts
print("Kidney classes counts:\n", kidney_classes)

# Print the total number of elements
print("Sum of elements is:", sum_of_elements)

splitfolders.ratio(
 "/content/CT-KIDNEY-DATASET-Normal-Cyst-Tumor-Stone/CT-KIDNEY-DATASET-Normal-Cyst-Tumor-Stone",
 output="./dataset",
 seed=7,
 ratio=(0.80,0.10, 0.10)
)
train_datagen = ImageDataGenerator(rescale=1/255)
valid_datagen = ImageDataGenerator(rescale=1/255)
test_datagen = ImageDataGenerator(rescale=1/255)
train_ctdataset = train_datagen.flow_from_directory('./dataset/train',
 target_size=(200, 200),
 color_mode='grayscale',
 class_mode='categorical',
 batch_size=100,
 )
test_ctdataset = test_datagen.flow_from_directory('./dataset/test',
 target_size=(200, 200),
 class_mode='categorical',
 color_mode='grayscale',
 batch_size=100,
 shuffle=False
)
valid_dataset = valid_datagen.flow_from_directory('./dataset/val',
 target_size=(200, 200),
 class_mode='categorical',
 batch_size=100,
 color_mode='grayscale',
 )

from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

model = Sequential()

# Convolutional layers with max pooling
model.add(Conv2D(32, (3, 3), activation='relu', input_shape=train_ctdataset.image_shape))
model.add(MaxPooling2D(2))

model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D(2))

model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(MaxPooling2D(2))

# Flatten layer to transition from convolutional layers to fully connected layers
model.add(Flatten())

# Fully connected layers with dropout for regularization
model.add(Dense(256, activation='relu'))
model.add(Dropout(0.5))

model.add(Dense(4, activation='softmax'))  #  4 classes

model.summary()

import matplotlib.pyplot as plt

# Compile the model with custom metrics
matrics = [
    'accuracy',
    keras.metrics.Precision(name='precision'),
    keras.metrics.Recall(name='recall')
]

model.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics=matrics)

# Fit the model and store the training history
history = model.fit(train_ctdataset, validation_data=valid_dataset, epochs=5)

# Access training and validation metrics from the history
training_accuracy = history.history['accuracy']
validation_accuracy = history.history['val_accuracy']

training_precision = history.history['precision']
validation_precision = history.history['val_precision']

training_recall = history.history['recall']
validation_recall = history.history['val_recall']

# Plot the training and validation metrics
plt.figure(figsize=(12, 6))

plt.subplot(1, 3, 1)
plt.plot(training_accuracy, label='Training Accuracy')
plt.plot(validation_accuracy, label='Validation Accuracy')
plt.title('Accuracy')
plt.legend()

plt.subplot(1, 3, 2)
plt.plot(training_precision, label='Training Precision')
plt.plot(validation_precision, label='Validation Precision')
plt.title('Precision')
plt.legend()

plt.subplot(1, 3, 3)
plt.plot(training_recall, label='Training Recall')
plt.plot(validation_recall, label='Validation Recall')
plt.title('Recall')
plt.legend()

plt.tight_layout()
plt.show()

print(test_ctdataset.classes.shape)
unique_classes = np.unique(test_ctdataset.classes)
num_classes = len(unique_classes)
print(f"Number of unique classes: {num_classes}")

import numpy as np

unique_classes = np.unique(test_ctdataset.classes)
num_classes = len(unique_classes)

print("Unique Classes:", unique_classes)
print("Number of Classes:", num_classes)

# Make predictions
predictions = model.predict(test_ctdataset)

# Convert predictions to class labels (one-hot encoding)
predicted_labels = np.argmax(predictions, axis=1)

# Ensure 'test_ctdataset.classes' is in the correct format (1D array)
actual_labels = test_ctdataset.classes

# Calculate confusion matrix
conf_matrix = confusion_matrix(actual_labels, predicted_labels)
print("Confusion Matrix:")
print(conf_matrix)

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, classification_report, ConfusionMatrixDisplay

# Assuming 'model' is your trained model and 'test_ctdataset' is your test dataset

# Make predictions
predictions = model.predict(test_ctdataset)

# Convert predictions to class labels (assuming one-hot encoding)
predicted_labels = np.argmax(predictions, axis=1)


actual_labels = test_ctdataset.classes

# Calculate confusion matrix
conf_matrix = confusion_matrix(actual_labels, predicted_labels)

# Plot confusion matrix using ConfusionMatrixDisplay class
disp = ConfusionMatrixDisplay(conf_matrix, display_labels=np.unique(actual_labels))
disp.plot(include_values=True, cmap=plt.cm.Blues, xticks_rotation='horizontal', values_format=None)
plt.title("Confusion Matrix")
plt.show()

# Display classification report
print("Classification Report:")
print(classification_report(actual_labels, predicted_labels))

